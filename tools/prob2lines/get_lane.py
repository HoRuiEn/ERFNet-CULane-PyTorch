## Code to generate lane coordinates from probablity maps.

import os
import numpy as np
import cv2

from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
from matplotlib.figure import Figure


class prob_to_lane:


    def __init__(self, dataRoot, probRoot, img_hw = (590, 1640), mask_hw = (208, 976), n_points=18, thres=0.3):

        self.dataRoot = dataRoot
        self.probRoot = probRoot
        
        self.img_height = img_hw[0]
        self.img_width = img_hw[1]
        self.mask_height = mask_hw[0]
        self.mask_width = mask_hw[1]
        
        self.n_points = n_points
        self.thres = thres

        self.plot_type = ['r-', 'g-', 'b-', 'y-']


    def get_lane(self, score_map):

        coordinate = np.zeros( self.n_points )

        for i in range(self.n_points):
            
            line_id = int(self.mask_height - i*20 / 350*self.mask_height) - 1
            line = score_map[line_id, :, 0]

            max_id = np.argmax(line)
            max_values = line[max_id]

            if max_values / 255.0 > self.thres:
                coordinate[i] = max_id
        
        n_valid_coords = np.sum( coordinate > 0 )
        if n_valid_coords < 2:
            coordinate = np.zeros( self.n_points )
        
        return(coordinate, n_valid_coords)
    
    
    def get_lines(self, img_path):
        
        exist_path = '%s%sexist.txt' %(self.probRoot, img_path[:-3])
        with open(exist_path) as f:
            exist = f.read().split(' ')

        coordinates = np.zeros( (4, self.n_points) )
        
        for j in range(4):
            if exist[j] == '1':
                score_path = '%s%s_%s_avg.png' %(self.probRoot, img_path[:-4], str(j+1))
                score_map = cv2.imread(score_path)
                coordinate, n_valid_coords = self.get_lane(score_map)
                coordinates[j, :] = coordinate
        
        return(coordinates)
    

    def visualise_lines(self, img_path, coordinates):
        
        print('%s%s' %(self.dataRoot, img_path))
        img = cv2.imread('%s%s' %(self.dataRoot, img_path) )

        # set up figure for plotting 1640x590, 
        fig = Figure( figsize=[self.img_width/100.0, self.img_height/100.0] )
        canvas = FigureCanvas(fig)
        axes = fig.add_axes( [0,0,1,1] )
        axes.imshow(img)

        # plot coordinates onto image 976x208
        for i in range(4):

            line = coordinates[i]
            line *= self.img_width / self.mask_width

            y_coord = self.img_height
            
            for j in range(self.n_points - 1):

                axes.plot( [line[j],line[j+1]], [y_coord, y_coord-20], self.plot_type[i])
                y_coord -= 20

        axes.axis('off')
        canvas.draw()
        image = np.frombuffer(canvas.tostring_rgb(), dtype='uint8')
        image = image.reshape(self.img_height, self.img_width-1, 3)
        cv2.imshow('Lane_Detection', image)



exp = 'vgg_SCNN_DULR_w9'    # Experiment name
dataRoot = '/home/whizz/Desktop/ERFNet/list'        # Data root
probRoot = os.path.join('/home/whizz/Desktop/ERFNet/predicts/', exp) # Directory where prob imgs generated by CNN are saved.
output = os.path.join('/home/whizz/Desktop/ERFNet/tools/output/', exp)         # Directory to save fitted lanes.
testList = os.path.join(dataRoot, 'test_img.txt')  # Directory to list of image paths
show = False  # set to true to visualize


with open(testList) as f:
    image_list = f.read().split('\n')
image_list = [ line.split(' ')[0] for line in image_list ]
image_list_len = len(image_list)


lane_converter = prob_to_lane(dataRoot, probRoot)


for i in range(image_list_len):

    if i%100 == 0:
        print('Processing %dth image...' %i)

    img_path = image_list[i]
    
    lines = lane_converter.get_lines(img_path)
    lane_converter.visualise_lines(img_path, lines)
    
    key = cv2.waitKey(10000) & 0xFF
    if key == ord('q'):
        break

cv2.destroyAllWindows()